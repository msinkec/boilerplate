struct ST1 {
    int x;
}

struct ST2 {
    ST1[2] s;
}

struct ST3 {
    ST1[2][2] s;
    bool a;
    bytes b;
}

struct ST4 {
    int[2][2][2] a;
    bool b;
    bytes c;
}

struct ST5 {
    ST3 a;
    ST4[2] b;
    int[2] c;
    bytes d;
}

library L {

    static const int N = 3;

    int[2][2] a;

    ST3[2][2] st3a;

    static function name(int x) : int {

        return x;
    }
}

contract C {
    static const int N = 1;
    //static int[3][3] SS = [[0,0, 0], [0,0, 0], [0,0,0]];
    int x;

    ST2[1] st2;

    int[2][2] aa;

    static int n = 1;

    // change st array
    public function unlock(int x) {
        ST5 st5 = { { [[{ 0 }, { 0 }], [{ 0 }, { 0 }]], false, b'' }, [{ [[[0, 0], [0, 0]], [[0, 0], [0, 0]]], false, b'' }, { [[[0, 0], [0, 0]], [[0, 0], [0, 0]]], false, b'' }], [0,0], b''};

        loop (2) : i {
            loop (2) : j {
                st5.a.s[i*x][j*x].x = 1;
            }
        }
        st5.a.a  = true;
        st5.a.b  = b'0101';


        loop (2) : i {
            loop (2) : j1 {
                loop (2) : j2 {
                    loop (2) : j3 {
                        st5.b[i*x].a[j1*x][j2*x][j3*x] = 1;
                    }
                }
            }
            st5.b[i*x].b = true;
            st5.b[i*x].b = true;
            st5.b[i*x].c = b'010101';
        }
        loop (2) : i {
            st5.c[i*x] = 1;
        }

        st5.d = b'0202';

        require(st5 == { { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'0101' }, [{ [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], true, b'010101' }, { [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], true, b'010101' }],[1,1], b'0202' });

        // L[2] l = [new L(this.aa, [[{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }], [{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }]]), 
        //     new L(this.aa, [[{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }], [{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }]])];
        --x;
        L l = new L(this.aa, [[{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }], [{ [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }, { [[{ 1 }, { 1 }], [{ 1 }, { 1 }]], true, b'00' }]]);
        l.a[x][x] = 11;
        l.a[0][x + 1] = 22;
        l.a[this.f1(x)][C.n] = 2;
        l.a[C.f2(++x)][C.n - 1] = 77;

        require(l.a == [[11, 22], [77, 2]]);

        l.st3a[x][x].s[0][this.f1(x) - 1].x = 3;
        require(l.st3a[x][x].s[0][this.f1(x) - 1] == { 3 });

        l.st3a[x][x].s[this.f1(x) / 2][0].x = 4;
        require(l.st3a[x][x].s[this.f1(x) / 2][0] == { 4 });

        require(true);
    }


    function f1(int x) : int {
        return x + 1;
    }

    static function f2(int x) : int {
        return x * 2 - 1;
    }
}
